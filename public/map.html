<!-- public/map.html -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8"/>
    <title>KiezTransit – Linienkarte</title>

    <!-- Leaflet CSS -->
    <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
            crossorigin=""
    />

    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: #111;
        }

        #map {
            width: 100vw;
            height: 100vh;
        }

        .stop-label {
            font-size: 11px;
            color: #222;
            background: rgba(255, 255, 255, 0.85);
            border: none;
            box-shadow: none;
            padding: 1px 4px;
        }

        .leaflet-control-attribution {
            font-size: 9px;
        }

        .map-title {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(17, 17, 17, 0.7);
            color: #f5f5f5;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div class="map-title">KiezTransit · Liniennetz</div>
<div id="map"></div>

<!-- Leaflet JS -->
<script
        src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""
></script>

<script>
    const map = L.map('map', {
        zoomControl: true
    });

    // Minimalistische Stadia-Map
    L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png', {
        maxZoom: 19
    }).addTo(map);

    let globalBounds = null;

    function extendGlobalBounds(bounds) {
        if (!globalBounds) {
            globalBounds = bounds;
        } else {
            globalBounds.extend(bounds);
        }
        map.fitBounds(globalBounds, {padding: [40, 40]});
    }

    function drawLine(lineMeta, lineData) {
        const color = lineMeta.color || lineData.color || '#ff0000';

        // Shape-Koordinaten: GeoJSON [lon, lat] -> Leaflet [lat, lon]
        let shapeLatLngs = [];
        if (lineData.shape && Array.isArray(lineData.shape.coordinates)) {
            shapeLatLngs = lineData.shape.coordinates.map(
                coord => [coord[1], coord[0]]
            );
        } else if (Array.isArray(lineData.shape)) {
            // Falls du später eine einfachere Struktur nutzt
            shapeLatLngs = lineData.shape.map(
                coord => [coord[1], coord[0]]
            );
        }

        if (shapeLatLngs.length > 0) {
            const polyline = L.polyline(shapeLatLngs, {
                color: color,
                weight: 3,
                opacity: 1
            }).addTo(map);

            extendGlobalBounds(polyline.getBounds());
        }

        // Stops
        if (Array.isArray(lineData.stops)) {
            lineData.stops.forEach(stop => {
                if (typeof stop.lat !== 'number' || typeof stop.lon !== 'number') return;

                const marker = L.circleMarker([stop.lat, stop.lon], {
                    radius: 4,
                    color: color,
                    weight: 2,
                    fillColor: '#ffffff',
                    fillOpacity: 1
                }).addTo(map);

                const label = stop.name || lineMeta.name || lineMeta.id;
                marker.bindTooltip(label, {
                    permanent: true,
                    direction: 'right',
                    offset: [8, 0],
                    className: 'stop-label'
                });
            });
        }
    }

    // Linien-Metadaten laden
    fetch('data/lines.json')
        .then(res => res.json())
        .then(lines => {
            if (!Array.isArray(lines)) {
                console.error('lines.json hat kein Array-Format');
                return;
            }

            lines.forEach(lineMeta => {
                const file = lineMeta.file;
                if (!file) return;

                fetch(`data/${file}`)
                    .then(res => res.json())
                    .then(lineData => {
                        drawLine(lineMeta, lineData);
                    })
                    .catch(err => {
                        console.error(`Fehler beim Laden von ${file}:`, err);
                    });
            });
        })
        .catch(err => {
            console.error('Fehler beim Laden von data/lines.json:', err);
        });
</script>
</body>
</html>